\documentclass[9pt,a4paper]{extarticle}
\usepackage{f1000_styles}
\usepackage{graphicx,url}

\newcommand{\code}[1]{{\small\texttt{#1}}}
\newcommand{\pkg}[1]{\textit{#1}}
\newcommand{\Biocpkg}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{{\small\texttt{#1}}}

% Allowing the large floats to have some text in those pages.
\renewcommand{\topfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}

\begin{document}
\pagestyle{front}

\title{From reads to genes to pathways: differential expression analysis of RNA-Seq experiments using Rsubread and the edgeR quasi-likelihood pipeline}

\author[1,2]{Yunshun Chen}
\author[3]{Aaron T. L. Lun}
\author[1,4]{Gordon K. Smyth}
\affil[1]{The Walter and Eliza Hall Institute of Medical Research, 1G Royal Parade, Parkville, Victoria 3052, Australia}
\affil[2]{Department of Medical Biology, The University of Melbourne, Victoria 3010, Australia}
\affil[3]{Cancer Research UK Cambridge Institute, University of Cambridge, Li Ka Shing Centre, Robinson Way, CB2 0RE, Cambridge, United Kingdom}
\affil[4]{Department of Mathematics and Statistics, The University of Melbourne, Victoria 3010, Australia}

\maketitle
\thispagestyle{front}

\begin{abstract}
In recent years, RNA sequencing (RNA-seq) has become a very widely used technology for profiling gene expression.
One of the most common aims of RNA-seq profiling is to identify genes or molecular pathways that are differentially expressed (DE) between two or more biological conditions.
This article demonstrates a computational workflow for the detection of DE genes and pathways from RNA-seq data by providing a complete analysis of an RNA-seq experiment profiling epithelial cell subsets in the mouse mammary gland.
The workflow uses R software packages from the open-source Bioconductor project and covers all steps of the analysis pipeline, including alignment of read sequences, data exploration, differential expression analysis, visualization and pathway analysis.
Read alignment and count quantification is conducted using the Rsubread package and the statistical analyses are performed using the edgeR package.
The differential expression analysis uses the quasi-likelihood functionality of edgeR.

\end{abstract}

\clearpage
\pagestyle{main}


<<style, echo=FALSE, results='hide', message=FALSE>>=
library(BiocStyle)
library(knitr)
opts_chunk$set(error=FALSE, prompt=TRUE, comment=NA)
opts_chunk$set(fig.width=7, fig.height=7, out.width="3.5in", fig.align="center", fig.path="")
opts_chunk$set(dpi=300, dev="png", dev.args=list(pointsize=15))
options(width=83)
@

\section*{Introduction}

In recent years, RNA sequencing (RNA-seq) has become a very widely used technology for profiling transcriptional activity in biological systems.
One of the most common aims of RNA-seq profiling is to identify genes or molecular pathways that are differentially expressed (DE) between two or more biological conditions.
Changes in expression can then be associated with differences in biology, providing avenues for further investigation into potential mechanisms of action.

This article provides a detailed workflow for analyzing an RNA-seq study from the raw reads through to differential expression and pathway analysis using Bioconductor packages \cite{huber2015orchestrating}.
The article gives a complete analysis of RNA-seq data that were collected to study the effects of pregnancy and lactation on the luminal cell lineage in the mouse mammary gland \cite{fu2015egfmcl1}.
The pipeline uses the \Biocpkg{Rsubread} package \cite{liao2013subread} for mapping reads and assigning them to genes, and the \Biocpkg{edgeR} package \cite{robinson2010edger} for statistical analyses.

RNA-seq analysis involves a number of steps, including read alignment, read summarization, differential expression and pathway analysis.
Here we use the Subread aligner \cite{liao2013subread} for mapping and featureCounts \cite{liao2014featurecounts} for assigning reads to genes.
As well as being fast and efficient, these algorithms have the advantage of having native implementations as R functions in the \pkg{Rsubread} package.
This means that the entire analysis can be conducted efficiently within the R environment.

The workflow uses \pkg{edgeR}'s quasi-likelihood pipeline (edgeR-quasi) for differential expression.
This statistical methodology uses negative binomial generalized linear models \cite{mccarthy2012edgerglm} but with F-tests instead of likelihood ratio tests \cite{lund2012quasiseq}.
This method provides stricter error rate control than other negative binomial based pipelines, including the traditional \pkg{edgeR} pipelines \cite{robinson2008smallsample,robinson2007moderated,mccarthy2012edgerglm} or \Biocpkg{DESeq2} \cite{love2014deseq2}.
The edgeR-quasi pipeline is based on similar statistical methodology to that of the \Biocpkg{QuasiSeq} package \cite{lund2012quasiseq}, which has performed well in third-party comparisons \cite{burden2014error}.
Compared to \pkg{QuasiSeq}, the \pkg{edgeR} functions offer speed improvements and some additional statistical refinements \cite{lun2016delicious}.
The RNA-seq pipelines of the \pkg{limma} package also offer excellent error rate control \cite{law2014voom,ritchie2015limma}.
While the \pkg{limma} pipelines are recommended for large-scale datasets, because of their speed and flexibility, the edgeR-quasi pipeline gives better performance in low-count situations \cite{lun2014denovo,lun2015diffhic}.
For the data analyzed here, the edgeR-quasi, limma-voom and limma-trend pipelines are all equally suitable and give similar results.

The analysis approach illustrated in this article can be applied to any RNA-seq study that includes some replication, but it is especially appropriate for designed experiments with multiple treatment factors and with small numbers of biological replicates.
The approach assumes that RNA samples have been extracted from cells of interest under two or more treatment conditions, that RNA-seq profiling has been applied to each RNA sample and that there are independent biological replicates for at least one of the treatment conditions.
The \pkg{Rsubread} part of the workflow takes FASTQ files of raw sequence reads as input, while the \pkg{edgeR} part of the pipeline takes a matrix of genewise read counts as input.


\section*{Description of the biological experiment}

This workflow demonstrates a complete bioinformatics analysis of an RNA-seq study that is available from the GEO repository as series GSE60450.
The RNA-seq data were collected to study the lineage of luminal cells in the mouse mammary gland and in particular how the expression profiles of the members of the lineage change upon pregnancy and lactation \cite{fu2015egfmcl1}.
Specifically, the study examined the expression profiles of basal stem-cell enriched cells (B) and committed luminal cells (L) in the mammary glands of virgin, pregnant and lactating mice.
There are therefore six groups of RNA samples, one for each combination of cell type and mouse status.
Two biological replicates were collected for each group.

This study used an Illumina Hiseq sequencer to generate about 30 million 100bp single-end reads for each sample.
Subread version 1.4.4 (\url{http://subread.sourceforge.net}) was used to align the reads to the mouse mm10 genome and featureCounts was used to assign reads to Entrez Genes using RefSeq gene annotation.
The FASTQ files containing the raw sequence reads were deposited to the Sequence Read Archive (SRA) repository and the read counts were deposited to GEO.

This experimental design is summarized in the table below, where the basal and luminal cell types are abbreviated with \code{B} and \code{L} respectively.
The GEO and SRA identifiers for each RNA sample are also shown:
<<sra>>=
targets <- read.delim("targets.txt", stringsAsFactors=FALSE)
targets
@
The experiment can be viewed as a one-way layout with six groups.
For later use, we combine the treatment factors into a single grouping factor:
<<group>>=
group <- paste(targets$CellType, targets$Status, sep=".")
group <- factor(group)
table(group)
@


\section*{Preliminary analysis}

\subsection*{Downloading the read counts}

Readers wishing to reproduce the analysis presented in this article can either download the matrix of read counts from GEO or recreate the read count matrix from the raw sequence counts.
We will present first the analysis using the downloaded matrix of counts.
At the end of this article we will present the R commands needed to recreate this matrix.

The following commands download the genewise read counts for the GEO series GSE60450.
The zipped tab-delimited text file \code{GSE60450\_Lactation-GenewiseCounts.txt.gz} will be downloaded to the working R directory:
<<checkdownload, echo=FALSE, results="hide", message=FALSE>>=
if( !file.exists("GSE60450_Lactation-GenewiseCounts.txt.gz") ) {
FileURL <- paste(
  "http://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE60450",
  "format=file",
  "file=GSE60450_Lactation-GenewiseCounts.txt.gz",
  sep="&")
download.file(FileURL, "GSE60450_Lactation-GenewiseCounts.txt.gz")
}
@
<<download, eval=FALSE>>=
FileURL <- paste(
  "http://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE60450",
  "format=file",
  "file=GSE60450_Lactation-GenewiseCounts.txt.gz",
  sep="&")
download.file(FileURL, "GSE60450_Lactation-GenewiseCounts.txt.gz")
@
The counts can then read into a data.frame in R:
<<readcounts>>=
GenewiseCounts <- read.delim("GSE60450_Lactation-GenewiseCounts.txt.gz",
                             row.names="EntrezGeneID")
colnames(GenewiseCounts) <- substring(colnames(GenewiseCounts),1,7)
dim(GenewiseCounts)
head(GenewiseCounts)
@
The row names of \code{GenewiseCounts} are the Entrez Gene Identifiers.
The first column contains the length of each gene, being the total number of bases in exons or UTRs for that gene.
The remaining 12 columns contain read counts and correspond to rows of \code{targets}.

The \pkg{edgeR} package stores data in a simple list-based data object called a \code{DGEList}.
This object is easy to use as it can be manipulated like an ordinary list in R, and it can also be subsetted like a matrix.
The main components of a \code{DGEList} object are a matrix of read counts, sample information in the \code{data.frame} format and optional gene annotation. 
We enter the counts into a \code{DGEList} object using the function \code{DGEList} in \pkg{edgeR}:
<<DGEList, message=FALSE>>=
library(edgeR)
y <- DGEList(GenewiseCounts[,-1], group=group,
             genes=GenewiseCounts[,1,drop=FALSE])
@

\subsection*{Adding gene annotation}

The Entrez Gene Ids link to gene information in the NCBI database.
The \Biocpkg{org.Mm.eg.db} package can be used to complement the gene annotation information.
Here, a column of gene symbols is added to \code{y\$genes}:
<<symbols, message=FALSE>>=
library(org.Mm.eg.db)
y$genes$Symbol <- mapIds(org.Mm.eg.db, rownames(y),
                         keytype="ENTREZID", column="SYMBOL")
head(y$genes)
@
Entrez Ids that no longer have official gene symbols are dropped from the analysis.
The whole \code{DGEList} object, including annotation as well as counts, can be subsetted by rows as if it was a matrix:
<<dropNAsymbols>>=
y <- y[!is.na(y$genes$Symbol), ]
dim(y)
@

\subsection*{Filtering to remove low counts}

Genes that have with very low counts across all the libraries should be removed prior to downstream analysis.
This is justified on both biological and statistical grounds.
From biological point of view, a gene must be expressed at some minimal level before it is likely to be translated into a protein or to be considered biologically important.
From a statistical point of view, genes with consistently low counts are very unlikely be assessed as significantly DE because low counts do not provide enough statistical evidence for a reliable judgement to be made.
Such genes can therefore be removed from the analysis without any loss of information.

The downstream differential expression analysis is not sensitive to the exact number of genes that are filtered.
As a rule of thumb, we require that gene have a count of at least 10--15 in at least some libraries before it is considered to be expressed in the study.
To account for differences in library sizes between samples, the filtering process is based on the count-per-million (CPM) values rather than on the counts directly.

For the current analysis, we keep genes that have CPM values above 0.5 in at least two libraries:
<<keep>>=
keep <- rowSums(cpm(y) > 0.5) >= 2
table(keep)
@
A CPM of 0.5 is used as it is equivalent to a count of 12--14 for the library sizes in this data set.
We demand that a gene is expressed in at least two libraries because each group contains two replicates.
This ensures that a gene will be retained if it is expressed in all the libraries belonging to any of the six groups.

The \code{DGEList} object is subsetted to retain only the non-filtered genes:
<<filter>>=
y <- y[keep, , keep.lib.sizes=FALSE]
@
Note that \code{keep.lib.sizes=FALSE} causes the library sizes to be recomputed after the filtering.
This is generally recommended, although the effect on the downstream analysis is usually small.

Note that the filtering rule should not make any reference to which RNA libraries belong to which group, because doing so would bias the subsequent differential expression analysis.


\subsection*{Normalization for composition bias}

Normalization by trimmed mean of M values (TMM) \cite{robinson2010tmm} is performed by using the \code{calcNormFactors} function, which returns the \code{DGEList} argument with only the \code{norm.factors} changed.
It calculates a set of normalization factors, one for each sample, to eliminate composition biases between libraries.
The product of these factors and the library sizes defines the effective library size, which replaces the original library size in all downstream analyses.
<<norm>>=
y <- calcNormFactors(y)
options(digits=3)
y$samples
@
The normalization factors of all the libraries multiply to unity.
A normalization factor below one indicates that a small number of high count genes are monopolizing the sequencing, causing the counts for other genes to be lower than would be usual given the library size.
As a result, the library size will be scaled down, analogous to scaling the counts upwards in that library.
Conversely, a factor above one scales up the library size, analogous to downscaling the counts.

The performance of the TMM normalization can be assessed by mean-difference (MD) plots.
This visualizes the library size-adjusted log-fold change between two libraries (the difference) against the average log-expression across those libraries (the mean).
The following command produces an MD plot which compares sample 1 to an artificial reference library constructed from the average of all other samples:
<<mdplot, fig.cap="MD plot of log2-expression in sample 1 versus the average log2-expression across all other samples. Each point represents a gene, and the red line indicates a log-ratio of zero. The majority of points cluster around the red line.">>=
plotMD(y, column=1)
abline(h=0, col="red", lty=2, lwd=2)
@
(see Figure~\ref{fig:mdplot}).
The bulk of the genes should be centered at a line of zero log-fold change if the composition bias between libraries has been removed successfully.
The quality check should be repeated with an MD plot for each of the other samples.


\subsection*{Exploring differences between libraries}

The RNA samples can be clustered in two dimensions using multi-dimensional scaling (MDS) plots.
This is a quality control step to explore the overall differences between the expression profiles of the different samples.
Here we decorate the MDS plot to indicate the cell groups:
<<mdsplot, fig.cap="The MDS plot of the data set. Samples are separated by the cell type in the first dimension, and by the mouse status in the second dimension.">>=
pch <- c(0,1,2,15,16,17)
colors <- rep(c("darkgreen", "red", "blue"), 2)
plotMDS(y, col=colors[group], pch=pch[group])
legend("topleft", legend=levels(group), pch=pch, col=colors, ncol=2)
@
(see Figure~\ref{fig:mdsplot}).
In the MDS plot, the distance between each pair of samples can be interpreted as the leading log-fold change between the samples for the genes that best distinguish that pair of samples.
By default, leading fold-change is defined as the root-mean-square of the largest 500 log2-fold changes between that pair of samples.
Figure~\ref{fig:mdsplot} shows that replicate samples from the same group cluster together while samples from different groups are well separated.
In other words, differences between groups are much larger than those within groups, meaning that there are likely to be statistically significant differences between the groups.
The distance between basal cells on the left and luminal cells on the right is about six units on the x-axis, corresponding to a leading fold change of about 64-fold between the two cell types.
The differences between the virgin, pregnant and lactating expression profiles appear to be magnified in luminal cells compared to basal.

\subsection*{Design matrix}

Linear modeling and differential expression analysis in \pkg{edgeR} requires a design matrix to be specified.
The design matrix records which treatment conditions were applied to each samples, and it also defines how the experimental effects are parametrized in the linear models.
The experimental design for this study can be viewed as a one-way layout and the design matrix can be constructed in a simple and intuitive way by:
<<design>>=
design <- model.matrix(~0+group)
colnames(design) <- levels(group)
design
@
This design matrix simply links each group to the samples that belong to it.
Each row of the design matrix corresponds to a sample whereas each column represents a coefficient corresponding to one of the six groups.


\subsection*{Dispersion estimation}

\pkg{edgeR} uses the negative binomial (NB) distribution to model the read counts for each gene in each sample.
The dispersion parameter of the NB distribution accounts for variability between biological replicates \cite{mccarthy2012edgerglm}.
\pkg{edgeR} estimates an empirical Bayes moderated dispersion for each individual gene.
It also estimates a common dispersion, which is a global dispersion estimate averaged over all genes, and a trended dispersion where the dispersion of a gene is predicted from its abundance.
Dispersion estimates are most easily obtained from the \code{estimateDisp} function:
<<estimateDisp>>=
y <- estimateDisp(y, design, robust=TRUE)
@
This returns a \code{DGEList} object with additional components added to hold the estimated dispersions.
Here \code{robust=TRUE} has been used to protect the empirical Bayes estimates against the possibility of outlier genes with exceptionally large or small individual dispersions \cite{phipson2016robust}.

The dispersion estimates can be visualized with \code{plotBCV}:
<<plotBCV, width="3.8in", fig.cap="Scatterplot of the biological coefficient of variation (BCV) against the average abundance of each gene. The plot shows the square-root estimates of the common, trended and tagwise NB dispersions.">>=
plotBCV(y)
@
(see Figure~\ref{fig:plotBCV}).
The vertical axis of the \code{plotBCV} plot shows square-root dispersion, also known as \emph{biological coefficient of variation} (BCV) \cite{mccarthy2012edgerglm}.

For RNA-seq studies, the NB dispersions tend to be higher for genes with very low counts.
The dispersion trend tends decrease smoothly with abundance and to asymptotic to a constant value for genes with larger counts.
From our past experience, the asymptotic value for the BCV tends to be in range from 0.05 to 0.2 for genetically identical mice or cell lines, whereas somewhat larger values ($>0.3$) are observed for human subjects.

The NB model can be extended with quasi-likelihood (QL) methods to account for gene-specific variability from both biological and technical sources \cite{lund2012quasiseq,lun2016delicious}.
Under the QL framework, the NB dispersion trend is used to describe the overall biological variability across all genes, and gene-specific variability above and below the overall level is picked up by the QL dispersion.
In the QL approach, the tagwise NB dispersions are not used.

The estimation of QL dispersions is performed using the \code{glmQLFit} function:
<<glmQLFit>>=
fit <- glmQLFit(y, design, robust=TRUE)
head(fit$coefficients)
@
This returns a \code{DGEGLM} object with the estimated values of the GLM coefficients for each gene.
It also contains a number of empirical Bayes (EB) statistics including the QL dispersion trend, the squeezed QL dispersion estimates and the prior degrees of freedom (df).
The QL dispersions can be visualized by \code{plotQLDisp}:
<<QLDisp, out.width="3.8in", fig.cap="A plot of the quarter-root QL dispersion against the average abundance of each gene. Estimates are shown for the raw (before EB moderation), trended and squeezed (after EB moderation) dispersions. Note that the QL dispersions and trend shown here are relative to the NB dispersion trend show in Figure~\ref{fig:plotBCV}.">>=
plotQLDisp(fit)
@
(see Figure~\ref{fig:QLDisp}).

The QL functions moderate the genewise the QL dispersion estimates in the same way that the \pkg{limma} package moderates variances \cite{smyth2004ebayes}.
The raw QL dispersion estimates are squeezed towards a global trend, and this moderation reduces the uncertainty of the estimates and improves testing power.
The extent of the squeezing is governed by the value of the prior df estimated from the data.
Large prior df estimates indicate that the QL dispersions are less variable between genes, meaning that strong EB moderation should be performed.
Smaller prior df estimates indicate that the true unknown dispersions are highly variable, so weaker moderation towards the trend is appropriate.
<<df.prior>>=
summary(fit$df.prior)
@

Setting \code{robust=TRUE} in \code{glmQLFit} is usually recommended \cite{phipson2016robust}.
This allows gene-specific prior df estimates, with lower values for outlier genes and higher values for the main body of genes.
This reduces the chance of getting false positives from genes with extremely high or low raw dispersions,
while at the same time increasing statistical power to detect differential expression for the main body of genes.


\section*{Differential expression analysis}

\subsection*{Testing for differential expression}

The next step is to test for differential expression between the experimental groups.
One of the most interesting comparisons is that between the basal pregnant and lactating groups.
The contrast corresponding to any specified comparison can be constructed conveniently using the \code{makeContrasts} function:
<<B.PvsL>>=
B.LvsP <- makeContrasts(B.lactating-B.pregnant, levels=design)
@
In subsequent results, a positive $\log_2$-fold-change (logFC) will indicate a gene up-regulated in lactating mice relative to pregnant, whereas a negative logFC will indicate a gene more highly expressed in pregnant mice.

We will use QL F-tests instead of the more usual likelihood ratio tests (LRT) as they give stricter error rate control by accounting for the uncertainty in dispersion estimation:
<<glmQLFTest>>=
res <- glmQLFTest(fit, contrast=B.LvsP)
@

The top DE genes can be viewed with \code{topTags}:
<<topTags>>=
topTags(res)
@
In order to control the false discovery rate (FDR), multiple testing correction is performed using the Benjamini-Hochberg method.
The top DE gene \emph{Csn1s2b} has a large positive logFC, showing that it is far more highly expressed in the basal cells of lactating than pregnant mice.
This gene is indeed known to be a major source of protein in milk.

The total number of DE genes identified at an FDR of 5\% can be shown with \code{decideTestsDGE}.
There are in fact more than 5000 DE genes in this comparison:
<<decideTests>>=
is.de <- decideTestsDGE(res)
summary(is.de)
@

The magnitude of the differential expression changes can be visualized with a fitted model MD plot:
<<plotMDfit, fig.cap="MD plot showing the log-fold change and average abundance of each gene. Significantly up and down DE genes are highlighted in red and blue, respectively.">>=
plotMD(res, status=is.de, values=c(1,-1), col=c("red","blue"),
       legend="topright")
@
(see Figure~\ref{fig:plotMDfit}).
The logFC for each gene is plotted against the average abundance in log2-CPM, i.e., \code{logCPM} in the table above.
Genes that are significantly DE are highlighted:    


\subsection*{Differential expression above a fold-change threshold}

\code{glmQLFTest} identifies differential expression based on statistical significance regardless of how small the difference might be.
For some purposes we might be interested only in genes with reasonably large expression levels. 
The above analysis found more than 5000 DE genes between the basal pregnant and lactating groups.
With such a large number of DE genes, it makes sense to narrow down the list to genes that are more biologically meaningful.

A commonly used approach is to apply FDR and logFC cutoffs simultaneously.
However this tends to favor lowly expressed genes, and also fails to control the FDR correctly.
A better and more rigorous approach is to modify the statistical test so as to detect expression changes greater than a specified threshold.
In \pkg{edgeR}, this can be done using the \code{glmTreat} function.
This function is analogous to the TREAT method for microarrays \cite{mccarthy2009treat} but is adapted to the NB framework.
Here we test whether the differential expression fold changes are significantly greater than 1.5, that is, whether the logFCs are significantly greater than $\log_2(1.5)$:
<<treat>>=
tr <- glmTreat(fit, contrast=B.LvsP, lfc=log2(1.5))
topTags(tr)
@
Note that the argument \code{lfc} is an abbreviation for ``log-fold-change''.
About 1100 genes are detected as DE with a FC significantly above 1.5 at an FDR cut-off of 5\%.
<<treatdecideTests>>=
is.de <- decideTestsDGE(tr)
summary(is.de)
@
The test results can be visualized in an MD plot:
<<plotMDtreat, fig.cap="MD plot showing the log-fold change and average abundance of each gene. Genes with fold-changes significantly greater than 1.5 are highlighted.">>=
plotMD(tr, status=is.de, values=c(1,-1), col=c("red","blue"),
       legend="topright")
@
(see Figure~\ref{fig:plotMDtreat}).

The p-values obtained by \code{glmTreat} are usually larger than those from \code{glmQLFTest} because the latter is testing the null hypothesis that the true logFC is zero.
\code{glmTreat} is testing a different hypothesis and requires stronger evidence for differential expression than conventional tests do.
It provides greater specificity for identifying the most important genes with large fold changes.

Note that the logFC threshold in \code{glmTreat} is not the same as a logFC cutoff.
Genes will need to exceed this threshold by some way before being declared statistically significant.
It is better to interpret the threshold as \emph{the FC below which we are definitely not interested in the gene} rather than \emph{the FC above which we are interested in the gene}.
The value of the FC threshold can be varied depending on the dataset.
In the presence of a huge number of DE genes, a relatively large FC threshold may be appropriate to narrow down the search to genes of interest.
In the absence of DE genes, on the other hand, a small or even no FC threshold shall be used.
If the threshold level is set to zero, then \code{glmTreat} reduces to \code{glmQLFTest} depending on the pipeline used in the analysis.
\code{glmTreat} can also be used with other \pkg{edgeR} pipelines, although we don't show that in this workflow.


\subsection*{Heat map clustering}

Heatmaps are a popular way to display differential expression results for publication purposes.
To create a heatmap, we first convert the read counts into log2-counts-per-million (logCPM) values.
This can be done with the \code{cpm} function:
<<cpm>>=
logCPM <- cpm(y, prior.count=2, log=TRUE)
rownames(logCPM) <- y$genes$Symbol
colnames(logCPM) <- paste(y$samples$group, 1:2, sep="-")
@
The introduction of \code{prior.count} is to avoid undefined values and to reduce the variability of the logCPM values for genes with low counts. 
Larger values for \code{prior.count} shrink the logFCs for low count genes towards zero. 

We will create a heatmap to visualize the top 30 DE genes according to the TREAT test between \code{B.lactating} and \code{B.pregnant}.
The advantage of a heatmap is that it can display the expression pattern of the genes across all the samples.
First we select the logCPM values for the 30 top genes:
<<order>>=
o <- order(tr$table$PValue)
logCPM <- logCPM[o[1:30],]
@
Then we scale each row (each gene) to have mean zero and standard deviation one:
<<scale>>=
logCPM <- t(scale(t(logCPM)))
@
A heat map can then be produced by the \code{heatmap.2} function in the \pkg{gplots} package:
<<heatmap, message=FALSE, fig.width=8, fig.height=12, fig.cap="Heat map across all the samples using the top 30 most DE genes between the basal lactating group and the basal pregnancy group.">>=
library(gplots)
col.pan <- colorpanel(100, "blue", "white", "red")
heatmap.2(logCPM, col=col.pan, Rowv=TRUE, scale="none", 
    trace="none", dendrogram="both", cexRow=1, cexCol=1.4,
    margin=c(10,9), lhei=c(2,10), lwid=c(2,6))
@
(see Figure~\ref{fig:heatmap}).
By default, \code{heatmap.2} clusters genes and samples based on Euclidean distance between the expression values.
Considering that we have pre-standardized the rows of the logCPM matrix, the use of Euclidean distance for the standardize values is equivalent to Pearson correlation between genes for the original logCPM values.
As expected, samples from the same group are clustered together.


\subsection*{Analysis of deviance}

The differential expression analysis comparing two groups can be easily extended to comparisons between three or more groups.
This is done by creating a matrix of independent contrasts.
In this manner, users can perform a one-way analysis of deviance (ANODEV) for each gene.

Suppose we want to compare the three groups in the luminal population, i.e., virgin, pregnant and lactating.
An appropriate contrast matrix can be created as shown below, to make pairwise comparisons between all three groups:
<<makeContrasts>>=
con <- makeContrasts(
     L.PvsL = L.pregnant - L.lactating,
     L.VvsL = L.virgin - L.lactating,
     L.VvsP = L.virgin - L.pregnant, levels=design)
@

The QL F-test is then applied to identify genes that are DE between the three groups.
This combines the three pairwise comparisons into a single F-statistic and p-value.
The top set of significant genes can be displayed with \code{topTags}:
<<anovaQLFtest>>=
res <- glmQLFTest(fit, contrast=con)
topTags(res)
@

Note that the three contrasts of pairwise comparisons are linearly dependent.
Constructing the contrast matrix with any two of the contrasts would be sufficient for an ANODEV test.
If the contrast matrix contains all three possible pairwise comparisons, then only the log-fold changes of the first two contrasts are shown in the output of \code{topTags}.


\subsection*{Complicated contrasts}

The flexibility of the GLM framework makes it possible to specify arbitrary contrasts for differential expression tests.
Suppose we are interested in testing whether the change in expression between lactating and pregnant mice is the same for basal cells it is for luminal cells. 
In statistical terminology, this is the interaction effect between mouse status and cell type.
The contrast corresponding to this testing hypothesis can be made as follows.
<<complicatedContrasts>>=
con <- makeContrasts(
     (L.lactating-L.pregnant)-(B.lactating-B.pregnant), 
     levels=design)
@
Then the QL F-test is conducted to identify genes that are DE under this contrast.
The top set of DE genes are viewed with \code{topTags}.
<<complicatedQLTest>>=
res <- glmQLFTest(fit, contrast=con)
topTags(res)
@


\section*{Pathway analysis}

\subsection*{Gene ontology analysis}

We now consider the problem of interpreting the differential expression results in terms of higher order biological processes or molecular pathways.
One of the most common used resources is gene ontology (GO) databases, which annotate genes according to a dictionary of annotation terms.
A simple and often effective way to interpret the list of DE genes is to count the number of DE genes that are annotated with each possible GO term.
GO terms that occur frequently in the list of DE genes are said to be over-represented or enriched.

In \pkg{edgeR}, GO analyses can be conveniently conducted using the \code{goana} function.
Here were apply \code{goana} to the output of the TREAT analysis comparing \code{B.lactating} to \code{B.pregant}.
The top most significantly enriched GO terms can be viewed with \code{topGO}.
<<goana>>=
go <- goana(tr, species="Mm")
topGO(go, n=15)
@
The \code{goana} function automatically extracts DE genes from the \code{tr} object, and conducts overlap tests for the up and down DE genes separately.
The row names of the output are the universal identifiers of the GO terms and the \code{Term} column gives the human-readable names of the terms.
The \code{Ont} column shows the ontology domain that each GO term belongs to.
The three domains are: biological process (BP), cellular component (CC) and molecular function (MF).
The \code{N} column represents the total number of genes annotated with each GO term.
The \code{Up} and \code{Down} columns indicate the number of genes within the GO term that are significantly up- and down-regulated in this differential expression comparison, respectively.
The \code{P.Up} and \code{P.Down} columns contain the p-values for over-representation of the GO term in the up- and down-regulated genes, respectively.

By default the output table from \code{topGO} is sorted by the minimum of \code{P.Up} and \code{P.Down}.
Other options are available.
For example, \code{topGO(go, sort="up")} lists the top GO terms that are over-represented in the up-regulated genes.
The domain of the enriched GO terms can also be specified by users.
For example, \code{topGO(go, ontology="BP")} returns the top GO terms belonging to the biological process domain.
This avoids other domains that are not of interest.

The \code{goana} function uses the NCBI RefSeq annotation and requires the use of Entrez Gene Identifiers.


\subsection*{KEGG pathway analysis}

Another popular annotation database is the Kyoto Encyclopedia of Genes and Genomes (KEGG).
Much smaller than GO, this is a curated database of molecular pathways and disease signatures.
A KEGG analysis can be done exactly as for GO, but using the \code{kegga} function:
<<kegga>>=
keg <- kegga(tr, species="Mm")
topKEGG(keg, n=15, truncate=34)
@
The output from \code{topKEGG} is the same as from \code{topGO} except that row names become KEGG pathway IDs, \code{Term} becomes \code{Pathway} and there is no \code{Ont} column.
Both the GO and KEGG analyses show that the cell cycle pathway is strongly down-regulated upon lactation in mammary stem cells.

By default, the \code{kegga} function automatically reads the latest KEGG annotation from the Internet each time it is run.
The KEGG database uses Entrez Gene Ids, and the \code{kegga} function assumes these are available as the row names of \code{tr}.


\subsection*{FRY gene set tests}

The GO and KEGG analyses shown above are relatively simple analyses that rely on a list of DE genes.
The list of DE genes is overlapped with the various GO and KEGG annotation terms.
The results will depend on the significance threshold that is used to assess differential expression.

If the aim is to test for particular gene expression signatures or particular pathways, a more nuanced approach is to conduct a \code{roast} or \code{fry} gene set test \cite{wu2010roast}.
These functions test whether a set of genes is DE, assessing the whole set of genes as a whole.
Gene set tests consider all the genes in the specified set and do not depend on any pre-emptive significance cutoff.
The set of genes can be chosen to be representative of any pathway or phenotype of interest.

\code{roast} gives p-values using random rotations of the residual space.
In the \pkg{edgeR} context, \code{fry} is generally recommended over \code{roast}.
\code{fry} gives an accurate analytic approximation to the results that \code{roast} would give, with default settings, if an extremely large number of rotations was used.

Here, suppose we are interested in three GO terms related to cytokinesis.
Each GO term is used to define a set of genes annotated with that term.
The names of these terms are shown below:
<<select, message=FALSE>>=
library(GO.db)
cyt.go <- c("GO:0032465", "GO:0000281", "GO:0000920")
term <- select(GO.db, keys=cyt.go, columns="TERM")
term
@

The first step is to extract the genes associated with each GO term from the GO database.
This produces a list of three components, one for each GO term.
Each component is a vector of Entrez Gene IDs for that GO term:
<<GO2ALLEGS>>=
Rkeys(org.Mm.egGO2ALLEGS) <- cyt.go
cyt.go.genes <- as.list(org.Mm.egGO2ALLEGS)
@
Suppose the comparison of interest is between the virgin and lactating groups in the basal population.
We can use \code{fry} to test whether the cytokinesis GO terms are DE for this comparison:
<<fry>>=
B.VvsL <- makeContrasts(B.virgin-B.lactating, levels=design)
fry(y, index=cyt.go.genes, design=design, contrast=B.VvsL)
@
Each row of the output corresponds to a gene set.
The \code{NGenes} column provides the number of genes in each set.
The \code{Direction} column indicates the net direction of change.
The \code{PValue} column gives the two-sided p-value for testing whether the set in DE as a whole, either up or down.
The \code{PValue.Mixed} column gives a p-value for testing whether genes in the set tend to be DE, without regard to direction.
The \code{PValue} column is appropriate when genes in the set are expected to be co-regulated, all or most changing expression in the same direction.
The \code{PValue.Mixed} column is appropriate when genes in the set are not necessarily co-regulated or may be regulated in different directions for the contrast in question.
FDRs are calculated from the corresponding p-values across all sets.

The results of a gene set test can be viewed in a barcode plot produced by the \code{barcodeplot} function.
Suppose visualization is performed for the gene set defined by the GO term GO:0032465:
<<barcode, fig.width=8, fig.height=5, out.width="5in", out.height="3.1in", fig.cap="Barcode plot showing enrichment of the GO term GO:0032465 in the basal virgin group compared to the basal lactating group. X-axis shows logFC for B.virgin vs B.lactating. Black bars represent genes annotated with the GO term. The worm shows relative enrichment.">>=
res <- glmQLFTest(fit, contrast=B.VvsL)
index <- rownames(fit) %in% cyt.go.genes[[1]]
barcodeplot(res$table$logFC, index=index, labels=c("B.virgin","B.lactating"), 
            main=cyt.go[1])
@
(see Figure~\ref{fig:barcode}).
In the plot, all genes are ranked from left to right by decreasing log-fold change for the contrast and the genes within the gene set are represented by vertical bars, forming the barcode-like pattern.
The curve (or \emph{worm}) above the barcode shows the relative local enrichment of the bars in each part of the plot.
The dotted horizontal line indicates neutral enrichment; the worm above the dotted line shows enrichment while the worm below the dotted line shows depletion.
In this particular barcode plot the worm shows enrichment on the left for positive logFCs, and depletion on the right for negative logFCs.
The conclusion is that genes associated with this GO term tend to be up-regulated in the basal cells of virgin mice compared to lactating mice, confirming the result of the \code{fry} test above.


\subsection*{Camera gene set enrichment analysis}

Finally we demonstrate a gene set enrichment style analysis using the Molecular Signatures Database (MSigDB) \cite{subramanian2005gsea}.
We will use the C2 collection of the MSigDB, which is a collection of nearly 5000 curated gene sets, each representing the molecular signature of a particular biological process or phenotype.
The MSigDB itself is purely human, but the Walter and Eliza Hall Institute maintains a mouse version of the database.
We load the mouse version of the C2 collection from the WEHI website:
<<camera>>=
load(url("http://bioinf.wehi.edu.au/software/MSigDB/mouse_c2_v5p1.rdata"))
@
This will load \code{Mm.c2}, which is a list of gene sets, each a vector of Entrez Ids.
This can be converted to a list of index numbers:
<<id2indices.Mm.c2>>=
idx <- ids2indices(Mm.c2,id=rownames(y))
@

First we compare virgin stem cells to virgin luminal cells:
<<cam.BVvsLV>>=
BvsL.v <- makeContrasts(B.virgin - L.virgin, levels=design)
cam <- camera(y, idx, design, contrast=BvsL.v, inter.gene.cor=0.01)
options(digits=2)
head(cam,14)
@
As expected, the mammary stem cell and mammary luminal cell signatures from Lim et al \cite{lim2010transcriptome} are top-ranked, and in the expected directions.

We can visualize the top signature, combining the up and down mammary stem cell signatures to make a bi-directional signature set:
<<barcode2, fig.width=8, fig.height=6.4, out.width="5.4in", out.height="4.3in", fig.cap="Barcode plot showing strong enrichment of mammary stem cell signature in the stem cell vs luminal cell comparison. Red bars show up signature genes, blue bars show down genes. The worms show relative enrichment.">>=
res <- glmQLFTest(fit, contrast=BvsL.v)
barcodeplot(res$table$logFC,
            index=idx[["LIM_MAMMARY_STEM_CELL_UP"]],
            index2=idx[["LIM_MAMMARY_STEM_CELL_DN"]],
            labels=c("B.virgin","L.virgin"),
            main="LIM_MAMMARY_STEM_CELL",
            alpha=1,)
@
(see Figure~\ref{fig:barcode2}).


\section*{Packages used}

This workflow depends on various packages from version 3.3 of the Bioconductor project, running on R version 3.3.0 or higher.
The complete list of the packages used for this workflow are shown below:
<<info>>=
sessionInfo()
@


\section*{Read alignment and quantification}

\subsection*{Software requirements}

We now revisit the question of recreating the matrix of read counts from the raw sequence reads.
Unlike the above workflow, which works for any version of R, read alignment requires Unix or Mac OS and, in practice, a high performance Unix server is recommended.
The following tasks require only one Bioconductor package, \pkg{Rsubread}.
However the \code{fastq-dump} utility from the SRA Toolkit is also required to convert from SRA to FASTQ format.
This can be downloaded from the NCBI website (\url{http://www.ncbi.nlm.nih.gov/Traces/sra/?view=software}) and installed on any Unix system.


\subsection*{Download files from the SRA}

The first task is to download the raw sequence files, which are stored in SRA format on the SRA repository.
The files can be conveniently located and downloaded by visiting the web page for the GEO data series GSE60450 at \url{http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE60450}, then following the ftp link at the foot of the page.

Once downloaded to the working directory, the 12 SRA files need to be unpacked into FASTQ format using the \code{fastq-dump} utility.
The following R code makes a system call to \code{fastq-dump} to convert each SRA file:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
for (sra in targets$SRA) {
    code <- system(paste("fastq-dump", sra))
    stopifnot(code==0L)
}
\end{verbatim}
\end{kframe}
\end{knitrout}
This will produce 12 FASTQ files with following names:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
all.fastq <- paste0(targets$SRA, ".fastq")
\end{verbatim}
\end{kframe}
\end{knitrout}


\subsection*{Build a genome index}

Before the sequence reads can be aligned, we need to build an index for the GRCm38/mm10 (Dec 2011) build of the mouse genome.
Most laboratories that use \pkg{Rsubread} regularly will already have an index file prepared, as this is a once-off operation for each genome release.
If you are using \pkg{Rsubread} for mouse for the first time, then the latest mouse genome build can be downloaded from the NCBI location
\url{ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCA_000001635.6_GRCm38.p4/GCA_000001635.6_GRCm38.p4_genomic.fna.gz}.
(Note that this link is for patch 4 of mm10, which is valid at the time of writing in May 2016.
The link will change as new patches are released periodically.)
An index can then be built by:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
library(Rsubread)
buildindex(basename = "mm10",
           reference = "GCA_000001635.6_GRCm38.p4_genomic.fna.gz")
\end{verbatim}
\end{kframe}
\end{knitrout}


\subsection*{Aligning reads}

The FASTQ files can now be aligned to the mouse genome using the \code{align} function:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
all.bam <- sub(".fastq", ".bam", all.fastq)
align(index="mm10", readfile1=all.fastq, input_format="FASTQ", 
      output_file=all.bam)
\end{verbatim}
\end{kframe}
\end{knitrout}
This produces a set of BAM files containing the read alignments for each RNA library.
The mapping proportions can be summarized by the \code{propmapped} function:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
> propmapped(all.bam)
          Samples NumTotal NumMapped PropMapped
1  SRR1552450.bam 30109290  26577308      0.883
2  SRR1552451.bam 28322351  24794251      0.875
3  SRR1552452.bam 31688348  27937620      0.882
4  SRR1552453.bam 29614284  26074034      0.880
5  SRR1552454.bam 27225012  24381742      0.896
6  SRR1552455.bam 25433157  22813815      0.897
7  SRR1552444.bam 27919481  23927833      0.857
8  SRR1552445.bam 29731031  25487822      0.857
9  SRR1552446.bam 29879070  25500318      0.853
10 SRR1552447.bam 29245388  25187577      0.861
11 SRR1552448.bam 31425424  27326500      0.870
12 SRR1552449.bam 31276061  27204156      0.870
\end{verbatim}
\end{kframe}
\end{knitrout}
Ideally, the proportion of mapped reads should be above 80\%.
By default, only reads with unique mapping locations are reported by \pkg{Rsubread} as being successfully mapped.
Restricting to uniquely mapped reads is recommended, as it avoids spurious signal from non-uniquely mapped reads derived from, e.g., repeat regions. 


\subsection*{Quantifying read counts for each gene}

The read counts for each gene can be quantified using the \code{featureCounts} function in \pkg{Rsubread}.
Conveniently, the \pkg{Rsubread} package includes inbuilt NCBI RefSeq annotation of the mouse and human genomes.
\code{featureCounts} generates a matrix of read counts for each gene in each sample:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
fc <- featureCounts(all.bam, annot.inbuilt="mm10")
\end{verbatim}
\end{kframe}
\end{knitrout}
The output is a simple list, containing the matrix of counts (\code{counts}), a data frame of gene characteristics (\code{annotation}), a vector of file names (\code{targets}) and summary mapping statistics (\code{stat}):
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
> names(fc)
[1] "counts"     "annotation" "targets"    "stat"    
\end{verbatim}
\end{kframe}
\end{knitrout}
The row names of \code{fc\$counts} are the Entrez gene identifiers for each gene.
The column names are the output file names from \code{align}, which we simplify here for brevity:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
colnames(fc$counts) <- rownames(targets)
\end{verbatim}
\end{kframe}
\end{knitrout}
The first six rows of the counts matrix are shown below.
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
> head(fc$counts)
          MCL1.DG MCL1.DH MCL1.DI MCL1.DJ MCL1.DK MCL1.DL MCL1.LA MCL1.LB MCL1.LC
497097        438     299      65     237     354     287       0       0       0
100503874       1       0       1       1       0       4       0       0       0
100038431       0       0       0       0       0       0       0       0       0
19888           1       1       0       0       0       0      10       3      10
20671         106     181      82     104      43      83      16      25      18
27395         309     232     339     290     291     270     558     468     488
          MCL1.LD MCL1.LE MCL1.LF
497097          0       0       0
100503874       0       0       0
100038431       0       0       0
19888           2       0       0
20671           8       3      10
27395         332     312     344
\end{verbatim}
\end{kframe}
\end{knitrout}

Finally, a \code{DGEList} object can be assembled by:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
y <- DGEList(fc$counts, group=group)
y$genes <- fc$annotation[, "Length", drop=FALSE]
\end{verbatim}
\end{kframe}
\end{knitrout}


\section*{Data and software availability}

Except for the targets file \code{targets.txt}, all data analyzed in the workflow is read automatically from public websites as part of the code.
All software used is publicly available as part of Bioconductor 3.3, except for the \code{fastq-dump} utility, which can be downloaded from NCBI website as described in the text.
The article includes the complete code necessary to reproduce the analyses shown.
The code will also be made available as an executable Bioconductor workflow at \url{http://www.bioconductor.org/help/workflows}.


\section*{Author contributions}

All authors developed and tested the code workflow.
All authors wrote the article.

\section*{Competing interests}

No competing interests were disclosed.

\section*{Grant information}

This worked was supported by the National Health and Medical Research Council
(Fellowship 1058892 and Program 1054618 to G.K.S, Independent Research Institutes Infrastructure Support to the Walter and Eliza Hall Institute)
and by a Victorian State Government Operational Infrastructure Support Grant.

\section*{Acknowledgments}

The authors thank Wei Shi and Yang Liao for advice with \pkg{Rsubread} and Yifang Hu for creating the mouse version of the MSigDB.


{\small\bibliographystyle{unsrt}
\bibliography{ref}}

\end{document}

